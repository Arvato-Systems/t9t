# 8. Cross-cutting Concepts

## Domain Concepts

### Multi-Tenancy

**Concept**: The t9t framework is built as a multi-tenant system from the ground up. Every entity belongs to a tenant, and tenant isolation is strictly enforced.

**Implementation**:
- `tenantId` field in all JPA entities
- Automatic tenant filter in all generated queries
- Tenant context in request processing
- Per-tenant configuration

**Tenant Resolution**:
1. From JWT token claims
2. From API key mapping
3. From subdomain (in UI access)
4. From request header

**Data Isolation**:
```sql
-- All queries automatically filtered
SELECT * FROM accounts WHERE tenant_id = :currentTenantId
```

**Configuration Hierarchy**:
- Global defaults
- Tenant-specific overrides
- Module-specific tenant configuration

### Request/Response Pattern

**Concept**: All business operations are modeled as request/response pairs using Bonaparte DTOs.

**Structure**:
```java
// Request
class MyBusinessRequest extends RequestParameters return MyBusinessResponse {
    required userId userId;
    required Unicode(50) parameter1;
    optional Integer parameter2;
}

// Response
class MyBusinessResponse extends ServiceResponse {
    required userId resultId;
    optional Unicode(200) resultMessage;
}
```

**Benefits**:
- Type-safe contracts
- Automatic serialization
- Version tracking
- Audit trail
- Easy testing (input/output pairs)

**Processing Pipeline**:
1. Deserialize request DTO
2. Validate request (structure, business rules)
3. Check authorization
4. Execute handler
5. Generate response DTO
6. Serialize response

### Tracking and Auditing

**Request Tracking**:
- Every request gets unique `objectRef` (process ID)
- Logged in `p42_int_request_log` table
- Contains: timestamp, user, tenant, request type, duration, return code

**Data Change Tracking**:
- Optional tracking columns per entity
- Track: who, when, reference to causing request
- Full audit trail for compliance (history)

**Execution Context**:
- Thread-local context with:
  - User ID
  - Tenant ID
  - Process reference
  - Language
  - Time zone

### Data Validation

**Multiple Validation Layers**:

1. **Structure Validation** (Bonaparte):
   - Field types enforced
   - Required vs optional
   - Length limits
   - Format constraints

2. **Business Validation** (Handler):
   - Business rule checks
   - Cross-field validation
   - Database constraints

3. **Authorization Validation**:
   - Permission checks
   - Resource ownership
   - Tenant access

**Error Handling**:
- Return codes in response
- Localized error messages
- Detailed technical logs
- User-friendly messages

## Technical Concepts

### Persistence Strategy

**Entity Generation**:
- Bonaparte BDDL files defines entities based on related DTOs
- Generated JPA entities with annotations
- Type-safe between Java and database
- Ensures consistency of fields (DTO vs entity vs UI)

**Example BDDL**:
```bddl
    entity UserEntity category cfg is UserDTO tablename p42_cfg_users historytablename p42_his_users {
        cacheable
        tenantClass InternalTenantId
        pk (objectRef)
        index unique (userId)
        index (userIdExt) where notNull
        @ManyToOne  RoleEntity roleE       EAGER for (roleRef)
        @ManyToOne  UserEntity supervisor  LAZY  for (supervisorRef)
        @Embeddable PermissionsEmbeddable        for permissions
    }
```
Specification of database table names is optional - if not provided, default names will be autogenerated.
The `category` defines whether a history table is created and references the object specifying the tracking columns for auditing.
```
    category cfg {
        trackinggroup FullTrackingWithVersion entityListener FullTrackingVEntityListener tablespacepattern "rts42dat0(DI)"
        history his sequence cm_idgen_5009_seq
        requiresPK
        beanVal
        grants apprw
    }
```


**Dual Connection Pools**:
- **Primary (Write)**: C3P0, for transactions
- **Shadow (Read)**: Hikari, for queries and reports

**Transaction Management**:
- Transactions per request
- Possible to invoke autonomous sub requests

**Optimistic Locking**:
- Version field in entities
- Concurrent modification detection
- Automatic retry for optimistic lock exceptions

### Caching Strategy

**Caching Layers**:

1. **Entity Cache (L1)**:
   - Hibernate session cache
   - Transaction-scoped
   - Automatic

2. **Second-Level Cache (L2)**:
   - Hibernate 2nd level cache
   - Configurable per entity
   - Cluster-aware via Hazelcast

3. **Configuration Cache**:
   - Module configurations
   - Tenant settings
   - Invalidation on update

4. **Translation Cache**:
   - UI labels and messages
   - Per language
   - Preloaded at startup

**Cache Invalidation**:
- Time-based (TTL)
- Event-based (on update)
- Manual invalidation APIs

### Session Management

**Stateless Architecture**:
- No HTTP session state
- All state in JWT token
- Horizontal scaling of backend without sticky sessions

**JWT Token Fields**:
```
    enum JwtFieldName {
        ISSUER                  = "iss",
        SUBJECT                 = "sub",        // user ID
        EXPIRATION              = "exp",
        NOT_BEFORE              = "nbf",
        ISSUED_AT               = "iat",
        JSON_TOKEN_IDENTIFIER   = "jti",
        NAME                    = "name",       // real name of the subject
        LOCALE                  = "locale",     // IETF BCP 47 language tag
        ZONEINFO                = "zoneinfo",   // time zone
        TENANT_ID               = "i",          // alphanumeric ID of the tenant
        TENANT_REF              = "t",          // numeric ID of the tenant (internal key)
        SESSION_REF             = "s",          // a unique reference for all contents of this token except iat, jti, exp (i.e. same for refreshes)
        USER_REF                = "u",
        ROLE_REF                = "r",          // restriction to role
        SESSION_ID              = "o",          // references a series of requests using the same JWT
        LOG_LEVEL_OK            = "l",
        LOG_LEVEL_ERR           = "e",
        RESOURCE_FILTER         = "p",
        RESOURCE_IS_WILDCARD    = "w",
        PERMISSION_MIN          = "pl",
        PERMISSION_MAX          = "pu",
        CUSTOM                  = "z"           // arbitray JSON element
    }
```

**Token Lifecycle**:
- Issued on successful login
- Client stores token (localStorage, cookie) or kept in the UI app server (for the ZK UI)
- Included in all subsequent requests
- Validated on every request
- Refreshable before expiration

**Security**:
- Tokens signed with HMAC, RSA, or ECDSA
- Configurable expiration
- Revocation via blacklist (from 9.1 onwards)

### Exception Handling

**Exception Hierarchy**:
```
ApplicationException (Root)
├── AuthorizationException
├── ValidationException
├── NotFoundException
├── ConcurrentModificationException
└── ...
```

**Error Response**:
```java
class ServiceResponse {
    required int returnCode;      // 0 = success, >0 = error code
    optional Unicode(512) errorMessage;
    optional Unicode(128) errorDetails;
}
```

**Handling Strategy**:
- Business exceptions → Specific return codes
- Technical exceptions → Generic error code
- Full stack trace in logs
- User-friendly message in response

**Retry Logic**:
- Automatic retry for transient failures
- Exponential backoff
- Configurable retry counts

### Logging Concept

**Structured Logging**:
- Logback with SLF4J
- MDC (Mapped Diagnostic Context) for request tracking
- JSON format for log aggregation

**Log Levels**:
- **ERROR**: Application errors, exceptions
- **WARN**: Unusual situations, degraded operation
- **INFO**: Important business events, startup/shutdown
- **DEBUG**: Detailed flow information
- **TRACE**: Very detailed, including data dumps

**Log Context (MDC)**:
```
messageId: jshdgfsjdhfgjsdh782345
processRef: 1234567890
requestPQON: t9t.auth.LoginRequest
```

**Log Rotation**:
- Daily or hourly rotation (configured in logback.xml)
- Compressed old logs (via cron job)
- Retention: 30 days local, longer in log aggregation

### Security Concepts

#### Authentication

**Supported Methods**:
1. **Username/Password**: Traditional login with SHA512 hashing
2. **API Keys**: For service-to-service authentication
3. **JWT Bearer**: Token-based for APIs
4. **SSO Integration**: Via MS Entra

**Password Policy**:
- Minimum length configurable
- Complexity requirements
- Expiration policy
- History tracking

#### Authorization

**Permission Model**:
- **Users** → **Roles** → **Permissions**
- Permissions are strings like `module.resource`
- 20 permission bits per entry: READ, WRITE, MERGE, SEARCH, ADMIN, ...


#### Data Encryption

**At Rest**:
- Database encryption (transparent data encryption)
- Encrypted backups
- Sensitive fields encrypted in database (responsibility of application)

**In Transit**:
- HTTPS/TLS 1.3 for all network communication

**Credential Storage**:
- JWT keystore (JCEKS format)
- Environment variables for secrets used in containers


### Configuration Concept

**Configuration Sources** (in precedence order):
1. **Environment Variables**: `T9T_PROPERTY_NAME`
2. **System Properties**: `-Dproperty.name=value`
3. **Properties Files**: `application.properties`
4. **XML Configuration**: `t9tconfig.xml`
5. **Database**: Module config tables

**Configuration Resolution**:
```java
String value = CONFIG_READER.getProperty("property.name", "defaultValue");
```

**Hot Reload**:
- Database configuration changes effective immediately or after cache expiry times (typically 1 minute for classic caches, 1 hour for eager caches)
- File-based config requires restart

### Internationalization (i18n)

**Supported Languages**:
- English
- German
- various others, depending on configuration

**Translation Storage**:
- Database tables: `p42_text_translation`
- Key-based lookups
- Fallback to default language

**Translation Resolution**:
1. User's preferred language (from context)
2. Tenant's default language
3. System default language (typically English)


### Error Handling and Recovery

**Retry Strategies**:

| Error Type | Retry | Backoff | Max Attempts |
|------------|-------|---------|--------------|
| Network timeout | Yes | Exponential | 3 |
| Database deadlock | Yes | Immediate | 5 |
| Optimistic lock | Yes | Immediate | 3 |
| Business validation | No | - | 1 |
| Authorization failure | No | - | 1 |

**Circuit Breaker**:
- For external service calls
- Prevents cascade failures
- Automatic recovery attempts

**Graceful Degradation**:
- Optional features fail safely
- Core functionality remains available
- User notified of degraded service

## Operational Concepts

### Monitoring Strategy

**Application Metrics**:
- Request count and latency
- Error rates by type
- Thread pool utilization
- Database connection pool stats
- Cache hit rates

**Business Metrics**:
- Active users
- Transactions per minute
- Document generation count
- Email queue depth

**Infrastructure Metrics**:
- CPU, memory, disk usage
- Network I/O
- JVM garbage collection
- Database query performance

**Metrics Collection**:
- JMX MBeans
- Prometheus metrics endpoint
- Custom metrics via Micrometer
- CloudWatch (AWS deployments)

### Deployment Strategy

**Blue-Green Deployment**:
- Deploy new version alongside old
- Switch traffic after validation
- Instant rollback capability

**Rolling Updates**:
- Update instances gradually
- Zero downtime
- Health checks ensure stability

**Database Migration**:
- Flyway-based versioned migrations
- Run before application startup
- Backward compatible changes preferred


### Disaster Recovery

**Backup Strategy**:
- **Database**: Daily full backup, continuous WAL archiving
- **File Storage**: depends on hosting (AWS vs Azure vs private cloud)
- **Configuration**: Version controlled

**Recovery Time Objective (RTO)**:
- Target: < 4 hours for full recovery
- Database restore: < 1 hour
- Application deployment: < 30 minutes

**Recovery Point Objective (RPO)**:
- Target: < 10 minutes of data loss
- Continuous replication for critical systems

**Disaster Recovery Site**:
- Active-passive configuration
- Regular DR drills
- Automated failover for AWS Aurora

### Performance Optimization

**Database Optimization**:
- Index optimization based on query patterns
- Partitioning for large tables
- Materialized views for reports
- Query plan analysis

**Application Optimization**:
- Connection pooling tuned per environment
- Thread pool sizing based on load
- Async processing for long operations
- Batch processing for bulk operations

**Caching Strategy**:
- Cache frequently accessed, rarely changed data
- Short TTLs for dynamic data
- Preload caches at startup

**Profiling**:
- JProfiler for production analysis
- Regular performance testing
- Load testing before releases

### Scalability Patterns

**Horizontal Scaling**:
- Add more application server instances
- Stateless design enables easy scaling
- Load balancer distributes requests

**Vertical Scaling**:
- Increase JVM heap size
- More CPU cores for thread pools
- SSD for database I/O

**Database Scaling**:
- Read replicas for query distribution
- Connection pooling to limit connections
- Query optimization to reduce load

**Async Processing**:
- Offload long-running tasks
- Kafka for distributed processing
- Scheduled jobs for batch work

### Development and Testing

**Local Development**:
- Docker Compose for full stack
- H2 in-memory database for quick tests
- Mock external services

**CI/CD Pipeline**:
- Build on commit
- Automated tests (unit, integration, architecture)
- Checkstyle validation
- ArchUnit tests
- Security scans
- Artifact publishing

**Testing Strategy**:
- **Unit Tests**: Fast, isolated, no external dependencies
- **Embedded Tests**: With in-memory H2 database
- **Remote Tests**: Against deployed instance, with real database (PostgreSQL)
- **Architecture Tests**: Enforce design rules
- **Load Tests**: Performance validation

**Test Data Management**:
- Synthetic test data generation
- Anonymized production data (where allowed)
- Test fixtures in version control

### Documentation Strategy

**Code Documentation**:
- Javadoc for public APIs
- Inline comments for complex logic
- README files per module

**Architecture Documentation**:
- arc42 documentation (this document)
- Architecture Decision Records (ADRs)
- Component diagrams

**User Documentation**:
- User guides for UI features / Confluence
- API documentation (Swagger/OpenAPI)
- Integration guides

**Runbooks**:
- Deployment procedures
- Troubleshooting guides
- Incident response procedures

**[TODO: Links to user documentation, API documentation locations, runbook repository]**
